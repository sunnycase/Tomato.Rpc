<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Reflection" #>
<#@ assembly name="$(TargetDir)$(TargetFileName)" #>
<#@ assembly name="$(TargetDir)Tomato.Rpc.Core.dll" #>
<#@ output extension=".cs" #>
<# var ifaceType = typeof(Tomato.Rpc.Test.Interface.ITest); #>
<# var serverClassName = "RpcCallingProxy"; #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using Tomato.Rpc.Packets;

namespace Tomato.Rpc.Client
{
<#
var builder = new CallingProxyBuilder(ifaceType);
builder.Build();
#>
	sealed class <#= serverClassName #> : <#= ifaceType.FullName #>
	{
		private readonly global::Tomato.Rpc.Core.IPacketSender _packetSender;

		public <#= serverClassName #>(global::Tomato.Rpc.Core.IPacketSender packetSender)
		{
			_packetSender = packetSender;
		}

<# foreach(var method in builder.PacketMethodPairs)
{
#>
		public void <#= method.MethodName #>(<#= string.Join(", ", method.Arguments.Select(o => o.Type + " " + o.Name)) #>)
		{
			var packet = new <#= method.PacketType #>
			{
<# foreach(var arg in method.Arguments)
{
#>
				Arg<#= arg.Index #> = <#= arg.Name #>,
<#
}
#>
			};
			_packetSender.Send(packet);
		}
<#
}
#>
	}
}

<#+
class PacketMethodPair
{
	public string MethodName;
    public string PacketType;
	public List<MethodArgument> Arguments;
}

class MethodArgument
{
	public string Type;
	public int Index;
	public string Name;
}

class CallingProxyBuilder
{
	private readonly Type _serviceType;

	public List<PacketMethodPair> PacketMethodPairs = new List<PacketMethodPair>();
	
    public CallingProxyBuilder(Type serviceType)
    {
        if (!serviceType.GetTypeInfo().IsInterface)
            throw new ArgumentException("Must be a interface type.", "serviceType");
        _serviceType = serviceType;
    }

	public void Build()
	{
        foreach (var method in from m in _serviceType.GetRuntimeMethods()
                               where m.ReturnType == typeof(void)
                               select m)
        {
            DefinePacketMethodPair(method);
        }
	}

    private void DefinePacketMethodPair(MethodInfo method)
    {
		var arguments = new List<MethodArgument>();
		var @params = method.GetParameters();
        for (int i = 0; i < @params.Length; i++)
        {
			var paramType = @params[i].ParameterType.IsByRef ? "ref " + @params[i].ParameterType.GetElementType().FullName : @params[i].ParameterType.FullName;
			arguments.Add(new MethodArgument
			{
				Type = paramType,
				Index = i,
				Name = @params[i].Name
			});
		}
		PacketMethodPairs.Add(new PacketMethodPair
		{
			MethodName = method.Name,
			PacketType = Uri.EscapeDataString(method.ToString()).Replace("%", "_"),
			Arguments = arguments
		});
    }
}
#>